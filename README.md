> 设计模式分为三种类型，23种

## 创建型模式

### 单例模式
- 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)
- 比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session 对象。 SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFactory就够，这是就会使用到单例模式

#### 单例模式有八种方式

1) 饿汉式(静态常量)
2) 饿汉式（静态代码块）
3) 懒汉式(线程不安全)
4) 懒汉式(线程安全，同步方法)
5) 懒汉式(线程安全，同步代码块)
6) 双重检查
7) 静态内部类
8) 枚举

#### 饿汉式(静态常量)

```
public class Single1 {
    private  Single1(){}
    private  static  Single1 single=new Single1();
    public static   Single1 getSingleton(){
        return  single;
    }
}
```

#### DCL 双重锁检查懒汉式 单列模式

```
public class SingleDcl {
    private  SingleDcl(){}
    private  volatile  static    SingleDcl single;
    public  SingleDcl getSingle(){
        if (single==null){
            synchronized(SingleDcl.class){
                if (single==null){
                    single=new SingleDcl();
                }
            }
        }
        return  single;
    }
}
```

#### 静态内部类-单例模式
- 这种方式采用了类装载的机制来保证初始化实例时只有一个线程
- 静态内部类方式在Single2类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingleInstance类，从而完成Singleton的实例化
- 类的静态属性只会在第一次加载类的时候初始化，所以在这里， JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的
- 避免了线程不安全，利用静态内部类特点实现延迟加载，效率高

```
public class Single2 {
    private  Single2 (){}

    private  static  class SingleInstance{
        private  static  final  Single2 INTEANCE=new Single2();
    }
    public  static  Single2 getInstance(){
        return  SingleInstance.INTEANCE;
    }
}
```
#### 枚举类-实现单例模式
- 借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象
- Effective Java作者Josh Bloch 提倡的方式

```
public enum  SingletinEnum {
    INSTANCE; //属性
    public void sayOK() {
        System.out.println("ok~");
    }
}
```

#### 单例模式注意事项和细节说明
- 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
- 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new
- 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)， 但又经常用到的对象、工具类对象、频繁访问数 据库或文件的对象(比如数据源、 session工厂等)


### 工厂模式(简单工厂模式)
- 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行
- 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象

> 优点：
- 1、一个调用者想创建一个对象，只要知道其名称就可以了。
- 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
- 3、屏蔽产品的具体实现，调用者只关心产品的接口。
  
> 缺点
- 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，
- 同时也增加了系统具体类的依赖。这并不是什么好事。    
      
> 使用场景    
- 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
- 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。
- 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。
      
### 工厂模式(工厂方法模式)
- 定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。
- 更符合开-闭原则: 新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可(简单工厂模式需要修改工厂类的判断逻辑)
- 符合单一职责原则: 每个具体工厂类只负责创建对应的产品 (简单工厂中的工厂类存在复杂的switch逻辑判断)
- 工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。

> 缺点
- 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；

> 工厂方法模式的应用场景：

- 当一个类不知道它所需要的对象的类时,在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可
- 当一个类希望通过其子类来指定创建对象时: 在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。


### 工厂模式(抽象工厂模式)
- 抽象工厂模式是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
- 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。
- 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。


### 原型模式
- 原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型， 创建新的对象
- 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节
- 工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()
- 形象的理解：孙大圣拔出猴毛， 变出其它孙大圣

> 浅拷贝和深拷贝

- 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
- 对于数据类型是引用数据类型的成员变量,比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。
- 因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值
- 深拷贝实现方式1：重写clone方法来实现深拷贝
- 深拷贝实现方式2：通过对象序列化实现深拷贝(推荐)

> 原型模式的注意事项和细节

- 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
- 不用重新初始化对象，而是动态地获得对象运行时的状态
- 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码
- 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则

### 建造者模式
- 建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式
- 它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象
- 建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节



## 结构型模式
- 适配器模式
- 桥接模式 
- 装饰模式
- 组合模式
- 外观模式
- 享元模式
- 代理模式

## 行为型模式
- 模版方法模式
- 命令模式
- 访问者模式
- 迭代器模式
- 观察者模式
- 中介者模式
- 备忘录模式
- 解释器模式（Interpreter模式）、
- 状态模式
- 策略模式
- 职责链模式(责任链模式)